// Copyright 2019, OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package translator

import (
	"encoding/json"

	"go.opentelemetry.io/collector/consumer/pdata"
	"go.opentelemetry.io/collector/translator/conventions"

	"github.com/open-telemetry/opentelemetry-collector-contrib/receiver/awsxrayreceiver/internal/tracesegment"
)

const (
	// just a guess to avoid too many memory re-allocation
	initAttrCapacity = 15
)

// ToTraces converts X-Ray segment (and its subsegments) to OT traces.
func ToTraces(rawSeg []byte) (*pdata.Traces, error) {
	var seg tracesegment.Segment
	err := json.Unmarshal(rawSeg, &seg)
	if err != nil {
		return nil, err
	}

	err = seg.Validate()
	if err != nil {
		return nil, err
	}

	traceData := pdata.NewTraces()
	rspanSlice := traceData.ResourceSpans()
	// ## allocate a new otlptrace.ResourceSpans for the segment document
	// (potentially with embedded subsegments)
	rspanSlice.Resize(1)      // initialize a new empty pdata.ResourceSpans
	rspan := rspanSlice.At(0) // retrieve the empty pdata.ResourceSpans we just created

	// ## initialize the fields in a ResourceSpans
	resource := rspan.Resource()
	resource.InitEmpty()
	// each segment (with its subsegments) is generated by one instrument
	// library so only allocate one `InstrumentationLibrarySpans` in the
	// `InstrumentationLibrarySpansSlice`.
	rspan.InstrumentationLibrarySpans().Resize(1)
	ils := rspan.InstrumentationLibrarySpans().At(0)
	count := totalSegmentsCount(&seg)
	ils.Spans().Resize(count)
	spans := ils.Spans()

	// populating global attributes shared among segment and embedded subsegment(s)
	populateInstrumentationLibrary(&seg, &ils)
	populateResource(&seg, &resource)

	// recursively traverse segment and embedded subsegments
	// to populate the spans. We also need to pass in the
	// TraceID of the root segment in because embedded subsegments
	// do not have that information, but it's needed after we flatten
	// the embedded subsegment to generate independent child spans.
	_, err = segToSpans(&seg, seg.TraceID, nil, &spans, 0)
	if err != nil {
		return nil, err
	}

	return &traceData, nil
}

func segToSpans(seg *tracesegment.Segment, traceID, parentID *string, spans *pdata.SpanSlice, startingIndex int) (int, error) {
	span := spans.At(startingIndex)

	err := populateSpan(seg, traceID, parentID, &span)
	if err != nil {
		return err
	}

	startingIndexForSubsegment := 1 + startingIndex
	for _, s := range seg.Subsegments {
		startingIndexForSubsegment, err = segToSpans(&s,
			traceID, seg.ID,
			spans, startingIndexForSubsegment)
		if err != nil {
			return err
		}
	}

	return startingIndexForSubsegment, nil
}

func populateSpan(seg *tracesegment.Segment, traceID, parentID *string, span *pdata.Span) error {
	attrs := span.Attributes()
	attrs.InitEmptyWithCapacity(initAttrCapacity)

	err := addNameAndNamespace(seg, span)
	if err != nil {
		return nil, err
	}

	if seg.TraceID == nil {
		// if seg.TraceID is nil, then `seg` must be an embedded subsegment.
		span.SetTraceID(pdata.TraceID([]byte(*traceID)))
	} else {
		span.SetTraceID(pdata.TraceID([]byte(*seg.TraceID)))
	}
	span.SetID(pdata.SpanID([]byte(*seg.ID)))
	addParentSpanID(seg, parentID, span)
	addStartTime(seg.StartTime, span)

	addEndTime(seg.EndTime, span)
	addBoolToSpan(seg.InProgress, xrayInProgressAttribute, span)
	addHTTPAndCause(seg, span)
	addAWSToSpan(seq.AWS, span)
	addSQLToSpan(seq.SQL, span)
	addStringToSpan(seg.User, conventions.AttributeEnduserID, span)

	// TODO: handle annotations and metadata

	// return the subsegment's ID to be used as the parentID of its subsegments
	return seg.ID
}

func populateResource(seg *tracesegment.Segment, rs *pdata.Resource) {
	// allocate a new attribute map within the Resource in the pdata.ResourceSpans allocated above
	attrs := rs.Attributes()
	attrs.InitEmptyWithCapacity(initAttrCapacity)

	addOrigin(seg.Origin, rs)
	addAWSToResource(seg.AWS, rs)
	addService(seg.Service, rs)
	addUser(seg.User)
}

func totalSegmentsCount(seg *tracesegment.Segment) int {
	subsegmentCount := 0
	for _, s := range seg.Subsegments {
		subsegmentCount += totalSegmentsCount(&s)
	}

	return 1 + subsegmentCount
}
